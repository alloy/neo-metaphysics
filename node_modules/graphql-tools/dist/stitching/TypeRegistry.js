"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var TypeRegistry = (function () {
    function TypeRegistry() {
        this.schemas = [];
        this.schemaByField = {};
        this.types = {};
        this.query = null;
        this.mutation = null;
        this.linksByType = {};
    }
    TypeRegistry.prototype.getSchemaByRootField = function (fieldName) {
        return this.schemaByField[fieldName];
    };
    TypeRegistry.prototype.getType = function (name) {
        if (!this.types[name]) {
            throw new Error("No such type: " + name);
        }
        return this.types[name];
    };
    TypeRegistry.prototype.getLinksByType = function (name) {
        return this.linksByType[name] || [];
    };
    TypeRegistry.prototype.getLinkByAddress = function (typeName, link) {
        if (typeName && link) {
            var links = this.getLinksByType(typeName);
            return links.find(function (_a) {
                var name = _a.name;
                return name === link;
            });
        }
        return null;
    };
    TypeRegistry.prototype.resolveType = function (type) {
        if (type instanceof graphql_1.GraphQLList) {
            return new graphql_1.GraphQLList(this.resolveType(type.ofType));
        }
        else if (type instanceof graphql_1.GraphQLNonNull) {
            return new graphql_1.GraphQLNonNull(this.resolveType(type.ofType));
        }
        else if (graphql_1.isCompositeType(type)) {
            return this.getType(type.name);
        }
        else {
            return type;
        }
    };
    TypeRegistry.prototype.addLinks = function (links) {
        var _this = this;
        links.forEach(function (link) {
            if (!_this.linksByType[link.from]) {
                _this.linksByType[link.from] = [];
            }
            _this.linksByType[link.from].push(link);
        });
    };
    TypeRegistry.prototype.addSchema = function (schema) {
        var _this = this;
        var query = schema.getQueryType();
        if (query) {
            var fieldNames = Object.keys(query.getFields());
            fieldNames.forEach(function (field) {
                _this.schemaByField[field] = schema;
            });
        }
        var mutation = schema.getMutationType();
        if (mutation) {
            var fieldNames = Object.keys(mutation.getFields());
            fieldNames.forEach(function (field) {
                _this.schemaByField[field] = schema;
            });
        }
        this.schemas.push(schema);
    };
    TypeRegistry.prototype.setType = function (name, type, onTypeConflict) {
        if (this.types[name]) {
            if (onTypeConflict) {
                type = onTypeConflict(this.types[name], type);
            }
            else {
                throw new Error("Type name conflict: " + name);
            }
        }
        this.types[name] = type;
    };
    TypeRegistry.prototype.setQuery = function (query) {
        this.query = query;
    };
    TypeRegistry.prototype.setMutation = function (mutation) {
        this.mutation = mutation;
    };
    return TypeRegistry;
}());
exports.default = TypeRegistry;
//# sourceMappingURL=TypeRegistry.js.map